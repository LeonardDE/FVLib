\documentclass[a4paper,12pt]{article}
% \documentclass[a4paper,12pt,draft]{article}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}

\usepackage[left=30mm,right=15mm,
    top=20mm,bottom=20mm,bindingoffset=0cm]{geometry}

\usepackage{floatrow}
\floatsetup[table]{style=Plaintop}
\usepackage[labelsep=period]{caption}

\usepackage[shortcuts]{extdash}

\usepackage{enumitem}
\setlist[itemize,2]{label=$\vartriangleright$}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{cite}
\usepackage{graphicx}
\usepackage[suffix=]{epstopdf}  
\usepackage[unicode, pdftex]{hyperref}

\usepackage{icomma}
\usepackage{multirow}
\usepackage{icomma}
\usepackage{indentfirst}


\title{DataMatrix}
\author{LeonarD DE}
\date{May 2024}

\newcounter{def}
\newcommand{\newdef}[1]{\addtocounter{def}{1}{\bf Определение \arabic{def}.} #1 \par}
\newcommand{\newdefnp}[1]{\addtocounter{def}{1}{\bf Определение} #1 \par}


\newtheorem{definit}{Определение}

\title{Диплом}
\author{LeonarD DE}
\date{April 2024}

\begin{document}

\begin{titlepage}

\begin{center}
{\bfseries Министерство науки и высшего образования Российской Федерации ФГАОУ ВО «УрФУ имени первого Президента России Б.Н. Ельцина»}
\end{center}
\begin{center}
Департамент математики, механики и компьютерных наук ФГАОУ ВО УрФУ ИЕНиМ.
\end{center}

\vspace{15mm}

\begin{flushright}
Оценка работы
\makebox[2in]{\hrulefill}\\
Руководитель от УрФУ Кумков С.С
\end{flushright}

\vspace{20mm}

\begin{center}
{\large Тема задания на практику}\\
\vspace{2mm}
Разработка программного комплекса моделирования и визуализации движения беспилотных летательных аппаратов
\end{center}

\vspace{2mm}

\begin{center}
{\large Отчет} \\
Вид практики Производственная практика\\
Тип практики Производственная практика, Преддипломная
\end{center}
\vspace{30mm}
\begin{flushleft}
Руководитель практики от предприятия (организации) Кумков С.С.\\
Студент Дербенев Л.О.\\
Специальность (направление подготовки) 01.03.01 Математика \\
Группа МЕН-400101
\end{flushleft}

\vspace{20mm}
\begin{center}
Екатеринбург 2024
\end{center}

\end{titlepage}

\newpage
\thispagestyle{plain}
\setcounter{page}{2}
\tableofcontents
\newpage

\addcontentsline{toc}{section}{Введение}
\setcounter{page}{3}

\section*{Введение}

В настоящее время активно развивается движение гражданских беспилотных летательных аппаратов (БПЛА). С их помощью проводится доставка различных грузов в удаленные поселки (чем раньше занималась только малая авиация), мониторинг состояния природных и искусственных объектов (лесов, озер, рек, трубо-, нефте- и газопроводов, ЛЭП и др.).

При этом конфликтов БПЛА и больших самолётов почти не возникает: в рабочем режиме они движутся на разных высотах, а вход БПЛА в аэропортовые зоны весьма жёстко регламентируется. Однако возникают конфликты БПЛА  с другими БПЛА, а также с самолётами малой авиации и вертолётами, которые движутся на тех же высотах, что и БПЛА. 

Ситуация такова, что движение БПЛА не диспетчеризируется централизовано, как движение больших самолётов, часто полет малого ЛА объявляется в уведомительном порядке. Поэтому текущая воздушная обстановка актуально недоступна операторам БПЛА, которые кроме того не имеют связи между собой и с диспетчерскими службами УВД. В то же время достаточно чётко прописаны регламенты того, какую информацию о собственном движении во время полёта БПЛА сообщает в эфир в виде широковещательных пакетов.

В таких условиях важной является разработка алгоритмов для бортовых компьютеров БПЛА для обработки полученной информации о движении окружающих аппаратов, малых и больших, и для последующей выработки и отработки манёвров, разрешающих возникающие конфликтные ситуации с другими летательными аппаратами. 

В рамках создания таких алгоритмов важным является численное моделирование ансамбля БПЛА, движущихся по тем или иным траекториям в тех или иных условиях. Такое моделирование позволяет провести предварительную оценку качества предлагаемых манёвров уклонения.

Однако для адекватности проводимых оценок требуется, чтобы модели движения и маневрирования БПЛА достаточно точно соответствовали движению реальных аппаратов. 

В рамках данной работы были предприняты шаги в направлении создания такого моделирующего программного комплекса и реализации основных моделей движения БПЛА.

\newpage

\section{Постановка задачи}
Требуется разработать комплекс моделирования движения ансамбля летательных аппаратов. Комплекс должен использовать созданные ранее процедуры моделирования движения летательного аппарата вдоль маршрута, представляющего собой ломаную линию с заданными моментами прибытия ЛА в точки излома. Движение ЛА описывается известных дифференциальных соотношений, включающих управляющие воздействия. Проход точек излома осуществляется прицеливанием постпредством пропорционального регулятора на точку, движущуюся по той или иной штурманской прокладке. В разрабатываемом комплексе нужно организовать вызов созданных ранее процедур в изменяющиеся моменты времени в соответствии с разворачивающейся обстановкой в воздушном пространстве.

\newpage



\section{Теоретическая часть}

\subsection{Рассматриваемые модели динамики}

\subsubsection{Материальная точка}

Материальная точка --- это идеализированное тело, обладающее массой, но не имеющее размеров. В физике материальная точка используется как модель для описания движения объекта, когда его размерами можно пренебречь по сравнению с масштабами задачи. В рамках создаваемого комплекса данная модель является вспомогательной, используемой при отладке его работы.

Материальная точка имеет следующую модель движения:
\begin{equation}
    \Ddot{r} = m \cdot u,
\end{equation}
где $r = (x, y, z)^\text{\textup{T}}$~--- радиус\=/вектор объекта, $m$~--- масса точки, $u = (u_x, u_y, u_z)^\text{\textup{T}}$~--- управление, являющееся ускорением.

Покоординатная запись:
\begin{align*}
\begin{cases}
    \ddot{x} = u_x, \\
    \ddot{y} = u_y, \\
    \ddot{z} = u_z
\end{cases}
\end{align*}

\subsubsection{Коптер}  

Недостаток модели материальной точки заключается в том, что нет никаких ограничений на максимальную скорость, развиваемую объектом, а также отсутствие учета сопротивления среды (воздуха) движению объекта.

Простейшей моделью, учитывающей эти обстоятельства, является модель, управляемая \textit{командным сигналом} скорости:
\begin{align*}
\begin{cases}
    \dot{x} = V_x, \\
    \dot{y} = V_y, \\
    \dot{z} = V_z, \\
    \displaystyle
    \dot{V_x} = \frac{u_x - V_x}{l_{xz}}, \\[1.75ex]
    \displaystyle
    \dot{V_y} = \frac{u_y - V_y}{l_{y}}, \\[1.75ex]
    \displaystyle
    \dot{V_z} = \frac{u_z - V_y}{l_{xz}}.
\end{cases}
\end{align*}
Здесь $u = (u_x, u_y, u_z)^\text{\textup{T}}$~--- управление, командный сигнал скорости, имеющий смысл желаемой скорости по каждой из координат; $l_{xz}$, $l_y$~--- коэффициенты инерции для горизонтальной скорости (в плоскости $XZ$) и вертикальной (вдоль оси $Y$), соответственно. После выставки командного сигнала на некоторый выбранный постоянный уровень актуальная скорость ЛА за время порядка $3l$ выходит на этот уровень.

Командный сигнал ограничен по модулю, что соответствует максимально возможной скорости, которую может развивать ЛА. 

Данная модель является простейшей моделью движения лёгкого коптера, который достаточно быстро может менять скорость своего движения, но имеет ограничение по максимальной скорости из-за относительно малой мощности двигателя. 


\subsection{Полетный план}

Вся траектория задается как $\{(r_i, t_i)\}_{i=1}^n$, где $r_i={x_i,y_i,z_i}$~--- точка трехмерного пространства, $t_i$~--- момент времени, в который БПЛА должен оказаться в заданной точке. Считаем, что $t_i < t_{i+1}$.


Заданная траектория, по определению, является ломаной линией. 
Пусть $n>1$, рассмотрим отрезок пути $(r_k,t_k)$, $(r_{k+1},t_{k+1})$, $k=1\dots n-1$. По определению, летательный аппарат должен оказаться в точке $r_k$ в момент времени $t_k$ и в точке $r_{k+1}$ в момент $t_{k+1}$. Или другими словами БПЛА должен пройти расстояние $S_k= |r_{k+1} - r_{k}|$ за время $\tau_i = t_{k+1} - t_{k}$. Значит мы можем найти скорость $V_k = \frac{S_k}{\tau_k}$.

Пусть теперь $n>2$, рассмотрим два отрезка, заданные тремя точками $(r_k,t_k)$, $(r_{k+1},t_{k+1})$, $(r_{k+2},t_{k+2})$ $k=1\dots n-2$. Найдем для скорости $V_k$ и $V_{k+1}$ для них, как это было сделано выше. Другими словами, наш БПЛА должен моментально сменить скорость в точке $(r_{k+1},t_{k+1})$ с $V_k$ на $V_{k+1}$, но в реальной жизни летательные аппараты так не могут. Данную проблемы решает \textit{штурманская прокладка}, она позволит плавно переходить с одного отрезка на другой и также плавно менять скорость. По сути аппарат будет прицеливаться на нее. О ее построении будет пункт чуть ниже.

???
И какие-то слова о том, что под углом летать не умеем~--- надо прокладку и прицеливаться на нее

\subsection{ПИД-регулятор}
ПИД-регулятор (пропорционально\=/интегрально\=/дифференциальный регулятор) является одним из наиболее распространенных методов регулирования систем управления. Он состоит из трех основных компонентов: пропорциональной, интегральной и дифференциальной составляющих.

Пропорциональная составляющая определяет выходной сигнал контроллера пропорционально разности между желаемым и текущим значением управляемой величины. Это позволяет реагировать на ошибку управления и регулировать систему.

Интегральная составляющая интегрирует ошибку управления с течением времени, что позволяет уменьшить статическую ошибку системы и обеспечить точное следование заданному значению.

Дифференциальная составляющая учитывает скорость изменения ошибок и предотвращает быстрые колебания системы, обеспечивая более плавное и стабильное управление.

В итоге, комбинация трех компонентов ПИД-регулятора позволяет эффективно и точно управлять системой, обеспечивая минимальное перерегулирование и быстрое достижение заданного значения.

Пусть $r$~--- заданное значение, которое нужно поддерживать, $e = (r-y)$ - невязка или ошибка регулирования. Тогда для линейной, стационарной системы ПИД-регулятор имеет вид:
\begin{equation}
    u(t) = P + I + D = K_p\cdot e(t) + K_i \cdot \int\limits_0^\text{\textup{T}} e(t) d\tau + K_d \frac{de}{dt},
\end{equation} 
где $K_p$, $K_i$, $K_d$~--- коэффициенты усиления пропорциональной, интегрирующей и дифференцирующей составляющих.

Рассмотрим простую линейную задачу:
\begin{equation}\label{PID}
    \Dot{x} = Ax + Bu,\quad x \in R^n, u \in R^m
\end{equation}

$u = 0 $~--- разрешенное управление. Отсюда следует, что $x = 0$ является точкой равновесия. Задача вывести систему в точку равновесия.

В данной работе был использован линейный пропорциональный регулятор, то есть $u = Kx$, где $K~\in~R^{m\times n}$.
Теперь задача имеет вид:
\begin{equation}\label{PID_lin}
    \Dot{x} = Ax + BKx = (A+BK)x
\end{equation}

Данная система является устойчивой $\Longleftrightarrow$ $\forall \lambda$~--- собственное значение, выполняется: $Re\lambda < 0$.

В данной работе будем использовать только пропорциональный регулятор:

$$u = -k_x \cdot (x - x_w) - k_V\cdot (V_x - V_{x,w})$$


\subsection{Построение регулятора для материальной точки}

Построим регулятор для материальной точки. Мы имеем
\begin{equation*}
    \Ddot{r} = u
\end{equation*}
или распишем в эквивалентной форме
\begin{align*}
    \ddot{x} = u_x \\
    \ddot{y} = u_y \\
    \ddot{z} = u_z
\end{align*}
Пусть $X = (x,y,z,v_x,v_y,v_z)^\text{\textup{T}}$, где $v_i$~--- соответствующие компоненты скорости.

Запишем задачу:
\begin{align*}
    \Dot{X} = AX + Bu =
            \begin{pmatrix}
                0& 0& 0& 1& 0& 0\\
                0& 0& 0& 0& 1& 0\\
                0& 0& 0& 0& 0& 1\\
                0& 0& 0& 0& 0& 0\\
                0& 0& 0& 0& 0& 0\\
                0& 0& 0& 0& 0& 0\\
            \end{pmatrix} 
            \cdot X +
            \begin{pmatrix}
                0& 0& 0\\
                0& 0& 0\\
                0& 0& 0\\
                1& 0& 0\\
                0& 1& 0\\
                0& 0& 1\\
            \end{pmatrix}
            \cdot u = 
            &\begin{pmatrix}
                O_3& I_3\\
                O_3& O_3\\ 
            \end{pmatrix}
            \cdot X +
            \begin{pmatrix}
                O_3\\
                I_3\\
            \end{pmatrix}
            \cdot u
\end{align*}
То есть можно сказать, что $K\in R^{3\times 6}$ или другими словами у нас 18 параметров, но заметим, что так как мы используем пропорциональный регулятор, то не равны нулю лишь $K_{x\rightarrow u_x}$, $K_{y\rightarrow u_y}$, $K_{z\rightarrow u_z}$, $K_{v_x\rightarrow u_x}$, $K_{v_y\rightarrow u_y}$, $K_{v_z\rightarrow u_z}$:

\begin{align*}
K =
\begin{pmatrix}
    K_{x\rightarrow u_x}& 0& 0& K_{v_x\rightarrow u_x} & 0& 0\\
    0& K_{y\rightarrow u_y} & 0& 0& K_{v_y\rightarrow u_y} & 0\\
    0& 0& K_{z\rightarrow u_z} & 0& 0& K_{v_z\rightarrow u_z} \\
\end{pmatrix}
\end{align*}

То есть получаем следую запись
\begin{align*}
    &\dot{x} = V_x\\
    &\dot{y} = V_y\\
    &\dot{z} = V_z\\
    &\dot{V}_x = K_x x + K_{V_x} V_x\\
    &\dot{V}_y = K_x x + K_{V_x} V_x\\
    &\dot{V}_z = K_x x + K_{V_x} V_x\\
\end{align*}



\subsection{Прокладка траектории полета}
Как уже упоминалось в одном из пунктов выше, летательные аппараты не умеют моментально менять скорость и ровно двигаться по заданным траекториям, из-за внешних и физических факторов. В данном пункте рассмотрим и построим траекторию полета.

\subsubsection{<<Наивная>> прокладка}
В данной ситуации прокладкой является та ломанная, которую нам дал пользователь. Как видно из раздела про Полетный план и моделирование движения, БПЛА будет постоянно сходить с заданной траектории, в местах, где нужно быстро изменить скорость и направление движения. Поэтому данный подход нам не подходит


\subsubsection{Прокладка с упреждением поворотов}
В этом случае главным отличием от <<Наивной прокладки>> будет перерасчет траектории с упреждением поворота. То есть мы будет пред-вычислять желаемые скорость и позицию в момент поворота.

Снова рассмотрим задачу с двумя отрезками заданными тремя точками. Пусть снова $n>2$, рассмотрим два отрезка, заданные тремя точками $(r_k,t_k)$, $(r_{k+1},t_{k+1})$, $(r_{k+2},t_{k+2})$ $k=1\dots n-2$. Найдем скорости $V_k$ и $V_{k+1}$ для них, как в пункте про полетный план. Давайте для простоты переобозначим точки и скорости следующим образом:

\begin{align*}
    &A:=r_k, \\
    &B:=r_{k+1},\\ 
    &C:=r_{k+2},\\
    &V_1 := V_k, \\
    &V_2:= V_{k+1}\\
\end{align*}

Примерно все выглядит следующим образом:

\begin{figure}[ht!]
\centering
\includegraphics[width=90mm]{3point.eps}
\caption{Два отрезка пути}\label{two_lines}
\end{figure}

По сути своей, нужно равноускоренно провести БПЛА по касательной окружности к данным отрезкам пути. Для этого понадобится узнать точки касания, боковое ускорение, угловую скорость и угол поворота. Каждый летательный аппарат имеет заданное боковое ускорение, обозначим его $a_n$.
Первым делом найдем радиус  по формуле: 
$$r = \frac{V_1^2}{a_n}$$
Затем найдем косинус угла $\alpha$ между отрезками $AB$ И $BC$ по известной формуле:
$$\cos{\alpha} = \frac{\langle V_1,V_2 \rangle}{|V_1||V_2|}$$
Теперь, зная радиус и угол между отрезками пути, можно найти длину $h$~--- расстояние от точки касания до точки стыка двух отрезков пути.

\begin{figure}[ht!]
\centering
\includegraphics[width=90mm]{3pointCircle.eps}
\caption{Касательная окружность к двум отрезкам пути.}\label{two_lines_and_circle}
\end{figure}
Как видно из рисунка~\ref{two_lines_and_circle}, так как радиус, проведенный в точку касания, перпендикулярен касательной линии, длину $h$ можно найти, вычислив тангенс половинного угла $\alpha$, затем умножив его на радиус $r$. По известной тригонометрический формуле 
$$
  \tg{\frac{\alpha}{2}} := \sqrt{\frac{1-\cos{\alpha}}{1+\cos{\alpha}}}.
$$
Значит 
$$h := r \cdot \sqrt{\frac{1-\cos{\alpha}}{1+\cos{\alpha}}}$$

Теперь можно найти координаты точек касания отступив от точки $B$, на расстояние $h$ вдоль отрезков. Для этого найдем нормированные вектора $a,c$, которые смотрят вдоль  на точки $A,  C $ соответственно: 
\begin{align*}
    &a:=\frac{BA}{|BA|},\\
    &c:=\frac{BC}{|BC|}
\end{align*}
.

Находим точки касания $A',C'$:
\begin{align*}
    &A' := a \cdot h, \\
    &C' := c \cdot h
\end{align*}
\newpage

\begin{figure}[ht!]
\centering
\includegraphics[width=90mm]{tochki_kasania.eps}
\caption{Касательная окружность к двум отрезкам пути.}\label{two_lines_and_circle_2}
\end{figure}

Так как траектория пути находится в трехмерном пространстве, нужно использовать формулу поворота для трехмерного пространства:
\begin{align*}\label{rotation_formula}
        &x' = (\cos{\theta} + n_x^2(1-\cos{\theta}))x + (n_x n_y (1-\cos{\theta}) - n_z\sin{\theta})y + (n_x n_z(1-\cos{\theta}) + n_y \sin{\theta})z \\
        &y' = (n_x n_y (1-\cos{\theta}) - n_z\sin{\theta})x + (\cos{\theta} + n_y^2(1-\cos{\theta}))y + (n_y n_z(1-\cos(\theta)) - n_x\sin{\theta})z\\
        &z' = (n_x n_z(1-\cos{\theta}) + n_y \sin{\theta})x + (n_y n_z(1-\cos(\theta)) - n_x\sin{\theta})y + (\cos{\theta} + n_z^2(1-\cos{\theta}))z
\end{align*}
где $n = (n_x,n_y,n_z)^\text{\textup{T}}$~--- нормированный вектор оси вращения, $\theta$~--- угол, на который нужно повернуть, $r' = (x',y',z')^\text{\textup{T}}$~--- новые координаты точки на окружности,$r=(x,y,z)^\text{\textup{T}}$ - старые координаты. Также, нужно учесть, что поворот в данной формуле происходит вокруг точки начала, то есть нужно будет сдвинуть старые координаты на радиус вектор центр окружности $r_0=(x_0,y_0,z_0)^\text{\textup{T}}$, а затем новые координаты сдвинуть обратно. То есть, формула будет выглядеть следующим образом:
\begin{align*}
        x' &= x_0 + (\cos{\theta} + n_x^2(1-\cos{\theta}))(x-x_0) + (n_x n_y (1-\cos{\theta}) - n_z\sin{\theta})(y - y_0)+{} \\ 
        & + (n_x n_z(1-\cos{\theta}) + n_y \sin{\theta})(z-z_0) \\
        y' &= y_0 + (n_x n_y (1-\cos{\theta}) - n_z\sin{\theta})(x - x_0) + (\cos{\theta} + n_y^2(1-\cos{\theta}))(y - y_0)+{} \\ 
        &+ (n_y n_z(1-\cos(\theta)) - n_x\sin{\theta})(z - z_0)\\
        z' &= z_0 + (n_x n_z(1-\cos{\theta}) + n_y \sin{\theta})(x - x_0) + (n_y n_z(1-\cos(\theta)) - n_x\sin{\theta})(y-y_0) +{} \\&+ (\cos{\theta} + n_z^2(1-\cos{\theta}))(z - z_0)
\end{align*}

Для нахождения вектора оси поворота $n$, нам понадобятся, уже известные, вектора $a$ и $c$, а точнее их векторное произведение, ведь по сути нам нужно найти нормированный вектор, перпендикулярный плоскости, в которой происходит поворот. А мы знаем что вектора $a,c$ лежат в этой плоскости. Находим вектор оси следующим образом:
$$n=\frac{c\times a}{|c\times a|}$$
Также, нужно отметить, что порядок умножения именно такой, ведь это задаст правильную ориентацию поворота.

%??? картинку с осью и углом поворота

%??? возможно стоит написать про то как правильно вычислять скорость
\subsection{Радиоканал}
У каждого ЛА на борту есть радиопередатчик. Раз в определенное время каждый аппарат сообщает свое текущее состояние, на момент вещания, и свой краткосрочный план движения. В текущее состояние входит такая информация как время вещания, имя ЛА, координаты позиции, вектор скорости, модуль скорости. А в краткосрочный план входят 4 будущие позиции маршрута, то есть координаты точек в пространстве и момент времени, когда ЛА будет в ней находится. 

Моменты на которые просчитываются прогнозы зафиксированы. При прохождении первой точки из набора она удаляется из набора и добавляется новая точка после последней и обновленный набор вещается в эфир.

При перестройке маршрута в эфир сообщается новый набор прогнозируемых точек.

Считается, что все бортовые часы БПЛА синхронизированы с достаточной точностью.

Вещание нужно для общения летательных аппаратов между собой, чтобы предотвращать конфликты.


\newpage
\section{Практическая часть}
Программа была реализована на языке C++, в среде разработки Microsoft Visual Studio. Выбор стал именно таким, так как он обеспечивает нужное быстродействие вычислений и кроссплатформенность. Все графики были сформированы в Gnuplot 6.0. В данный момент в программе реализовано две динамические модели~--- материальная точка и коптер. 

\subsection{Вспомогательные классы и методы}
Для данной работы были написаны вспомогательные классы  и методы для работы с ними такие как:
\begin{itemize}
    \item \texttt{Vector3}~--- класс для удобной работы с трехмерными векторами. По сути своей класс обладает тремя полями $x,y,z$ для определения координат. В нем были реализованы базовые операции над векторами: 
    \begin{itemize}
      \sloppy
        \item \texttt{+}~--- сложения и вычитание векторов
        \item \texttt{*}~--- умножения вектора на скаляр
        \item \texttt{/}~--- деления вектора на скаляр
        \item \texttt{*}~--- умножение вектора на скаляр
        \item \texttt{double scalarProduct(Vector3 v1, Vector3 v2)}~--- скалярное произведение трёхмерных векторов
        \item \texttt{Vector3 crossProduct(Vector3 v1, Vector3 v2)}~--- векторное произведение трёхмерных векторов
  
        \item \texttt{void rotate(Vector3 axis, Vector3 axisPoint, double angle)}~--- операция поворота вектора вокруг заданной оси и точки, через которую проходит это ось, на заданный угол
        \item \texttt{double norm()}~--- подсчет длины вектора
        \item \texttt{Vector3 getNormVector()}~--- получение нормированного вектора из данного
    \end{itemize}
    \item \texttt{Point}~--- структура для описание точки пути, который задает пользователь. Он состоит из полей:
    \begin{itemize}
        \item \texttt{Vector3 position}~--- поле для хранения координат позиции точки
        \item \texttt{double time}~--- момент времени, в который должен оказаться ЛА в заданной позиции
    \end{itemize}
    \item \texttt{TurnData}~--- структура для хранения данных, которые нужно для поворота. Имеет следующею поля:
    \begin{itemize}
        \item \texttt{double angularVelocity}~--- поле для хранения предвычисленного углового ускорения, используется для поворота позиции по окружности
        \item \texttt{Vector3 axisPoint}~--- поле для хранения точки оси поворота
        \item \texttt{double angularVelocity\_0}~--- поле для хранения предвычисленного углового ускорения, используется для вычисления скорости при повороте
        \item \texttt{double angularAcceleration}~--- поле для хранения углового ускорения
        \item \texttt{Vector3 axis}~--- поле для хранения оси поворота
    \end{itemize}
    \item \texttt{PathPointType}~--- класс перечислений, для пометки точек траектории прокладки. Содержит:
        \begin{itemize}
            \item \texttt{DEFAULT}~--- тип для обозначения точки, после которой движение прямолинейное, равномерное.
            \item \texttt{START\_TURN}~--- тип для обозначения точки, после которой начинается маневр поворота 
        \end{itemize}
    \item \texttt{PathPoint}~--- структура для описания точки пути прокладки, является наследником класса \texttt{Point}. Состоит из:
    \begin{itemize}
        \item \texttt{Vector3 position}~--- поле для хранения координат позиции точки
        \item \texttt{double time}~--- момент времени, в который должен оказаться ЛА в заданной позиции
        \item \texttt{PointType type}~--- поле для типа точки
        \item  \texttt{TurnData turnData}~--- поле для данные поворота. 
    \end{itemize}
    \item \texttt{Path}~--- класс для описания пути прокладки. Имеет следующие методы и поля:
    \begin{itemize}
        \item \texttt{vector<PathPoint> path}~--- приватное поле для хранения вектора, состоящего из точек типа. \texttt{PathPoint}.
        \item \texttt{PathPoint getPointForIndex(int ind)}~--- метод для получения точки пути по индексу.
        \item \texttt{void addNewPoint(PathPoint p)}~--- метод для добавления точки в траекторию прокладки.
    \end{itemize}
    \item \texttt{FVState}~--- структура для передачи состояния и короткого плана в радиоканал.  
    \begin{itemize}
        \item \texttt{Plane plane}~--- поле для записи текущего состояния
        \item \texttt{vector<Point>}~--- поле для записи плана движения на следующие 4 точки пути.
    \end{itemize}
    \item \texttt{AEtherInfo}~--- класс, который служит радиоканалом для всех ЛА.  
    \begin{itemize}
        \item \texttt{map<string,FVState> states}~---  поле куда ЛА записывают свои данные.
        \item \texttt{void broadcastState(const Plane\& plane)}~--- метод, принимающий текущее состояние ЛА и записывает в соответствующее поле радиоканала.
        \item \texttt{void broadcastPlan(const string\& name,\\ const vector<Point>\& shortPlan)}~--- метод, который принимает имя и короткий маршрутный план и записывает их соответствующее поле радиоканала.
    \end{itemize}
    \item \texttt{GlobalSituation}~--- класс для хранения глобального состояния всего моделирования.  
    \begin{itemize}
        \item \texttt{vector<FV*> FVs}~---  поле для хранения ссылок на каждый ЛА, участвующий в моделировании.
        \item \texttt{AEtherInfo aetherInfo}~--- поле для хранения радиоканала моделирования.
    \end{itemize}
     \item \texttt{Modeler}~--- класс для инкапсуляции всего процесса моделирования.
    \begin{itemize}
        \item \texttt{void startModeling()}~---  метод для запуска процесса  моделирования.
        \item \texttt{double solve\_time}~--- поле для хранения промежутка времени, на которое нужно делать следующее вычисление.
        \item \texttt{double integral\_h}~--- поле для хранения шага интегрирования.
        \item \texttt{int solve\_part\_count}~--- поле для хранения количества вычислений.
        \item \texttt{double start\_time}~--- поле для хранения момента времени начала вычислений.
        \item \texttt{double end\_time}~--- поле для хранения момента времени конца вычислений.
        \item \texttt{GlobalSituation globalSituation}~--- поле для хранения глобальных данных моделирования.
    \end{itemize}
\end{itemize}

\subsection{Реализация динамических моделей}
Для реализации динамических моделей был создан базовый абстрактный класс FV. Он определяет базовые свойства присущие каждой модели движения, такие как:
\begin{itemize}
    \item     \texttt{virtual void next(double h, double end\_time) = 0}~--- виртуальная функция, которая служит для вычисления следующего состояния БПЛА с шагом $h$ до момента $end\_time$.
    \item \texttt{virtual void setPath(vector<Point> path)}~--- виртуальная функция, которая служит для вычисления прокладки пути. По умолчанию вычисляется по схеме прокладки с упреждением поворота.
    \item \texttt{vector<Point> getBasePath()}~--- возвращает базовый путь, введенный пользователем.
    \item \texttt{Path getDynamicPath()}~--- возвращает построенный путь прокладки при задании пути.
    \item \texttt{vector<Point> basePath}~--- поле для хранения базового пути, который вводит пользователь.
    \item \texttt{Path dynamicPath}~--- поле для хранения, пути прокладки, заданной с помощью метода  \texttt{setPath}.
    \item \texttt{virtual double solveTurnRadius(const Vector3\& v1, const Vector3\& v2)}~---\\ метод,  принимающий две скорости ЛА на соседних промежутках. Вычисляет радиус поворота.
    \item \texttt{double time}~--- поле для хранения времени текущего состояния БПЛА
     \item \texttt{double broadсastStep}~--- поле, в котором записан шаг вещания.
      \item \texttt{double nextBroadcastInstant}~--- поле для следующего момента времени вещания.
    \item \texttt{GlobalSituation\* globalSituation}~--- поле для хранения указателя на глобальное состояние.
\end{itemize}
Далее рассмотрим подробнее конкретные реализации динамических моделей~--- материальной точки и коптера, которые являются наследниками класса \texttt{FV}

\subsubsection{Материальная точка}
Класс материальной точки \texttt{MaterialPoint} является публичным наследником класса \texttt{FV}. А значит обладает всеми уже ранее описанными методами и полями, но также имеет и собственные. А именно:
\begin{itemize}
    \item \texttt{string getName()}~--- метод возвращающий имя БПЛА.
    \item \texttt{int32\_t getType()}~--- метод метод возвращающий тип БПЛА, у материальной точки 0.
    
    \item \texttt{Vector3 acceleration}~--- поле которое хранит ускорение в текущем состоянии.
    \item \texttt{Vector3 wishPosition}~--- поле хранящее желаемую позицию, вычисленную в методе \texttt{computeWishData}.
    \item \texttt{Vector3 wishVelocity}~--- поле хранящее желаемую скорость, вычисленную в методе \texttt{computeWishData}.
    \item \texttt{string name}~--- поле, содержащее имя БПЛА.
    \item \texttt{int32\_t type}~--- поле, хранящее тип БПЛА.

    \item\texttt{Vector3* curPosition}~--- поле хранящее указатель на текущую позицию БПЛА.
    \item\texttt{Vector3* newPosition}~--- поле хранящее указатель на новую позицию, вычисленную в методе \texttt{next}.
    \item\texttt{Vector3* curVelocity}~--- поле хранящее указатель на текущую скорость БПЛА.
    \item\texttt{Vector3* newVelocity} поле хранящее указатель на новую скорость, вычисленную в методе \texttt{next}
    \item\texttt{double k\_v}~--- поле хранящее значение коэффициента вклада позиции на управление.
    \item\texttt{double k\_x}~--- поле хранящее значение коэффициента вклада скорости на управление.
    \item\texttt{double maxAcceleration}~--- поле хранящее значение максимального ускорения.\textbf{}
    
    \item\texttt{void computeWishData(double time\_solve)}~--- метод предназначенный для вычисления желаемой позиции и желаемой скорости в момент времени \texttt{time\_solve}
\end{itemize}

\subsubsection{Коптер}
Класс коптер \texttt{Copter}, также как и материальная точка является публичным наследником класса \texttt{FV}. А значит обладает всеми уже ранее описанными методами и полями, но также имеет и собственные, почти во всем перекликается с материальной точкой, но также имеет собственные особенности:
\begin{itemize}
    \item \texttt{double inertialXZ}~--- поле для хранения коэффициента инерции в плоскости $OXZ$. 
    \item \texttt{double inertialY}~--- поле для хранения коэффициента инерции по оси $OY$.
\end{itemize}
\subsection{Вычисление <<штурманской>> прокладки}

\subsubsection{Разметка траектории}
Разберем весь процесс вычисления, того как должен двигаться БПЛА. 
Начнем с метода \texttt{setPath} прописанного в базовом классе \texttt{FV}.
Данный метод, как упоминалось ранее, принимает вектор из точек траектории пользователя, а затем пробегает по всем его точкам, проверяя отрезки на наличии поворотов.
Если поворот нужен, то вместо точек стыка двух отрезок заменяют две точки, к которые являются касательными. Первая точка касания помечается типом \texttt{PointPathType::START\_TURN} и для нее вычисляются все данные для поворота, указанные в структуре \texttt{TurnData}. После данного процесса полученный путь сохраняется в поле \texttt{Path dynamicPath}.

%???? Нужна ли вставка с кодом ????
\subsubsection{Вычисление прокладки}
Метод \texttt{computeWishData} вычисляет \texttt{wishPosition, wishVelocity} желаемые позицию и скорость соответственно по моменту времени. Данный метод идентичен как в классе \texttt{MaterialPoint}, так и в классе \texttt{Copter}. В самом начале бинарным поиском происходит нахождение соответствующего отрезка в \texttt{Path dynamicPath}. Затем, относительного типа точки пути вычисляется желаемая скорость, а после желаемая позиция. Если точка имеет тип \texttt{DEFAULT}, то это значит что нужно двигаться равномерно, прямолинейно до следующей точки, если же тип \texttt{START\_TURN}, то используя данные для поворота из соответствующего поля структуры, вычисляем скорость, находя касательный к окружности вектор, с помощью векторного произведения вектора угловой скорости и радиус вектора с началом в точке в центре окружности и концом в точке позиции БПЛА. Для вычисления новой позиции на окружности, последняя позиция двигается с помощью метода \texttt{rotate}, в котором реализована формула поворота.

\subsubsection{Вычисление движения}
Теперь перейдем к методу \texttt{next} для материальной точки. В данном методе происходит вычисление действительной позиции и скорости БПЛА посредством численного интегрирования. Для интегрирования используется метод Эйлера на левый край, где за производную управление берется регулятор, построенный в соответствующем пункте теоретической части. Регулятор используется один и тот же как для материальной точки:
\begin{verbatim}
for (int i = 0; i < 3; i++) {
    double x = (*curPosition)[i];
    double v = (*curVelocity)[i];
    (*newPosition)[i] = x + h * v;
    (*newVelocity)[i] = v + h * k_x * (x -  wishPosition[i] 
                              + k_v * (v - wishVelocity[i]));
    acceleration[i] = k_x * (x - wishPosition[i]) 
                    + k_v * (v - wishVelocity[i]);
}
\end{verbatim}
так и для коптера:
\begin{verbatim}
double x = (*curPosition)[0];
double v = (*curVelocity)[0];
(*newPosition)[0] = x + h * v;
(*newVelocity)[0] = v + h * 
        ((k_v * wishVelocity.x + k_x * wishPosition.x) - v) / inertialXZ;
x = (*curPosition)[1];
v = (*curVelocity)[1];

(*newPosition)[1] = x + h * v;
(*newVelocity)[1] = v + h * 
        ((k_v * wishVelocity.y + k_x * wishPosition.x) - v) / inertialY;

x = (*curPosition)[2];
v = (*curVelocity)[2];

(*newPosition)[2] = x + h * v;
(*newVelocity)[2] = v + h * 
        ((k_v * wishVelocity.z + k_x * wishPosition.x) - v) / inertialXZ;
\end{verbatim}
\subsection{Результаты}

В данном пункте пошагово пройдемся по этапам вычисления. Пусть пользователь задал такой маршрут состоящий из 4 точек: 
\begin{itemize}
    \item $(r_1,t_1) = ((0,0,0),0)$~--- точка для нулевого момента времени,
    \item $(r_2,t_2) = ((10,0,0),10)$~--- точка для 10 секунды,
    \item $(r_3,t_3) = ((10,0,-5),20)$~--- точка для 20 секунды,
    \item $(r_3,t_3) = ((10,0,-15),30)$~--- точка для 30 секунды
\end{itemize}

\begin{figure}[ht!]
\centering
\includegraphics[width=90mm]{default_path.eps}
\caption{ Путь пользователя}\label{user_path}
\end{figure}

Продемонстрирую поведение материальной точки стоящей в нулевой момент времени в точке$(0,0,0)$, с начальной скорость $(0,0,0)$ если использовать <<Наивную>> прокладку. Пусть коэффициенты вклада в управление для позиции и скорости соответственно $k_x = -1$ =,  $k_v = -1$, 

\begin{figure}[H]
\centering
\includegraphics[width=90mm]{default_path_not_procladka.eps}
\caption{ Путь пользователя}\label{not_prokladka}
\end{figure}

Как видно по зеленой линии, летательный аппарат не успевает изменить скорость на повороте.
Теперь построим прокладку с упреждение поворота:

\begin{figure}[ht!]
\centering
\includegraphics[width=90mm]{default_path_prokladka.eps}
\caption{ Путь пользователя и прокладка}\label{prokladka}
\end{figure}

Посмотрим как будет себя вести БПЛА, нацелившийся на прокладку: 

\begin{figure}[ht!]
\centering
\includegraphics[width=90mm]{default_path_prokladka_position.eps}
\caption{ Путь пользователя}\label{user_path_position}
\end{figure}

Как видно, результат стал намного лучше. Более лучше результата можно добиться подбором коэффициентов $k_x$ и $k_v$, уменьшая или увеличивая вклад желаемых позиции и скорости.

\newpage
\addcontentsline{toc}{section}{Заключение}
\section*{Заключение}
В работе описано построение процедур моделирования движения летательного аппарата вдоль маршрутов, представляющих собой ломаную линию с заданными моментами прибытия ЛА в точки излома. Движение ЛА описывается известных дифференциальных соотношений, включающих управляющие воздействия. Проход точек излома осуществляется прицеливанием постпредством пропорционального регулятора на точку, движущуюся по той или иной штурманской прокладке.    
\newpage
\addcontentsline{toc}{section}{Список литературы}
\begin{thebibliography}{99}
\bibitem{cppSHILD}
Шилдт Герберт C++ базовый курс  [Электронный ресурс]:
Белорусский государственный университет информатики и радиоэлектроники~--- Режим доступа: \url{https://www.bsuir.by/m/12_119786_1_98220.pdf}
(дата обращения: 01.12.2023)

\bibitem{MSC} 
Документация по Microsoft C++, C и ассемблеру [Электронный ресурс]:-- Режим доступа:
\url{https://learn.microsoft.com/ru-ru/cpp/?view=msvc-170} (дата обращения: 01.12.2023).

\end{thebibliography}
\end{document}
